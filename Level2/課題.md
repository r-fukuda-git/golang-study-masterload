## 課題2：シンプルな`grep`コマンドクローンの作成

`grep`は指定したパターンに一致する行を検索して表示する、非常に強力なコマンドです。その基本的な機能を実装してみましょう。

### 要件

1.  **検索パターンとファイル指定**

      * コマンドライン引数のうち、**フラグ以外の最初の引数**を「検索パターン」とします。
      * それ以降の引数を、検索対象の「ファイルパス」とします。（0個でも複数でも可）

2.  **検索と出力**

      * 各ファイルを1行ずつ読み込み、その行に「検索パターン」が含まれていれば、その行を標準出力に表示してください。

3.  **標準入力からの読み込み**

      * ファイルパスが一つも指定されなかった場合は、**標準入力**から入力を受け付け、同様にパターンを含む行を標準出力に表示してください。
      * これにより `other_command | go run main.go "pattern"` のようなパイプライン処理が可能になります。

4.  **行番号表示フラグの実装**

      * `-n` というコマンドラインフラグを実装してください。
      * `-n` フラグが指定された場合、出力する行の先頭に「`行番号:`」を付けてください。（例: `5:一致した行のテキスト`）

5.  **エラーハンドリング**

      * ファイルが開けないなどのエラーが発生した場合は、標準エラー出力にメッセージを表示し、次のファイルの処理を続けてください。（これは前回の課題と同じです）

### 実行例

```bash
# text.txtの中身
Hello Go
Hello World
Goodbye Go

# 基本的な検索
$ go run main.go "Go" text.txt
Hello Go
Goodbye Go

# 行番号付きの検索
$ go run main.go -n "World" text.txt
2:Hello World

# パイプを使った標準入力からの検索
$ cat text.txt | go run main.go -n "Go"
1:Hello Go
3:Goodbye Go
```

### ヒント

  * **フラグの解析:** Goの標準ライブラリには、コマンドラインフラグを簡単に扱うための `flag` パッケージがあります。
      * `flag.Bool()` で `-n` のようなON/OFFフラグを定義できます。
      * `flag.Parse()` を呼び出すと、プログラムが引数を解析してくれます。
      * フラグ以外の引数（今回のパターンやファイル名）は `flag.Args()` で取得できます。
  * **文字列の検索:** 文字列の中に特定のパターンが含まれているかどうかは、`strings` パッケージの `strings.Contains()` 関数が便利です。
  * **標準入力の扱い:** `os.Stdin` はファイルと同じように扱うことができます。`bufio.NewScanner(os.Stdin)` のようにすれば、標準入力を行単位で読み込めます。

この課題は前回より少し複雑になりますが、今のあなたなら必ずできます。焦らず、まずは「ファイルからパターンを検索する」という一番シンプルな機能から一つずつ実装してみてください。

楽しんで挑戦してくださいね！

参照元：
https://qiita.com/t-yama-3/items/99ecf0466e5e0f080815
