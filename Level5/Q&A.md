### Webスクレイピングとは？

Web上の特定の情報を自動的に抽出する技術を指します。スクレイピング（Scraping）とは「Scrape（こする・かき出す）」からきている言葉であり、情報をこするようにかき出すといった意味合いを持ちます。

### `links := []string{}` は可変長の配列？

はい、そのイメージで**ほぼ正解**です。 👍

Goではこれを**スライス (slice)** と呼びます。配列と似ていますが、スライスは長さを変えられる、より柔軟で強力なデータ構造です。「`string`（文字列）を入れるための、**空っぽの可変長リスト**を用意する」という意味になります。

-----

### `<a>`タグの`href`属性の値をリストにするとは？

これは、HTMLのリンクがどのように書かれているかに関係します。HTMLでは、リンクは`<a>`というタグで表現されます。

```html
<a href="https://www.google.com">Googleへのリンク</a>
<a href="/about.html">会社概要ページへ</a>
```

ここで、

  * `<a>`: これが**タグ**です。
  * `href`: これが**属性**です。
  * `"https://www.google.com"` や `"/about.html"`: これが`href`属性の**値**（実際のリンク先）です。

「`href`属性の値をリストにする」とは、ウェブページの中からこれらの`"..."`の部分だけをすべて集めてきて、先ほど用意した`links`スライスに格納していく、という意味です。

-----

### `links = append(links, href)` は何をしている？

これは、スライスに新しい要素を追加する処理です。

`append`は「付け加える」という意味の英単語です。`links = append(links, href)`というコードは、「**`links`スライスに、`href`変数の内容を付け加えて、新しいスライスとして`links`を更新する**」と読んでください。

`links`スライスに、見つかったリンクが一つずつ追加されていくイメージです。

-----

### `href, exists := s.Attr("href")` の解説

これは、`go-query`ライブラリの機能で、Goの**多重代入**という特徴を使っています。`s.Attr("href")`は2つの値を同時に返します。

1.  **`href` (string):** `href`属性の値そのもの（例: `"/about.html"`）。もし`href`属性がなければ、空の文字列`""`が返されます。
2.  **`exists` (bool):** `href`属性が**存在したかどうか**を`true`か`false`で教えてくれます。

この書き方によって、「`href`属性が存在した場合だけ処理する」という安全なコードを`if exists { ... }`のように簡単に書くことができます。

-----

### URLを「パース」するとは？

「パース (parse)」とは、**文字列を分解して、プログラムが扱いやすい構造的なデータに変換すること**を意味します。

URLはただの文字列ですが、`https://example.com:80/path?query=1`のように、

  * `https`: スキーム（通信方法）
  * `example.com`: ホスト（ドメイン）
  * `/path`: パス
    のように、複数の部品から成り立っています。

`url.Parse(urlString)`を実行すると、このバラバラの部品を格納した`URL`構造体に変換してくれます。これにより、「このURLのドメインだけ欲しい」といった操作が簡単にできるようになります。

1.  **起点となるURLをパース:** これから見つける相対パス（`/about`など）を絶対パス（`https://.../about`）に変換するための**基準**となるURLを準備する処理です。
2.  **抽出したhrefをパース:** 見つけたリンクが相対パスなのか絶対パスなのかなどを判断するために、同様に構造体に変換する処理です。

-----

### `strings.HasPrefix()`と`baseURL.ResolveReference()`の役割

  * **`baseURL.ResolveReference(hrefURL)`**
    これが**相対URLを絶対URLに変換する**ための魔法です。

      * `baseURL`（例: `https://example.com/news/`）を基準にして、
      * `hrefURL`（例: `../contact.html`）がどこを指すのかを計算し、
      * 完全なURL（例: `https://example.com/contact.html`）を返してくれます。

    バラバラの部品を基準点につなぎ合わせるイメージです。

  * **`strings.HasPrefix(absoluteURL, "http")`**
    これは、ある文字列が特定の文字列で**始まっているかどうか**を調べる関数です。`Has Prefix`は「接頭辞を持つ」という意味です。
    `ResolveReference`で変換した結果、`mailto:test@...`（メールリンク）や`javascript:void(0)`（実行コード）のような、HTTPリクエストを送るべきではないリンクも紛れ込んでいます。この関数を使って、「**このリンクは`http`（または`https-`）で始まっていますか？**」と確認し、ウェブページのリンクだけを厳選しているのです。

-----

### `make`関数とチャネルについて

はい、その通りです。`make(chan string)`は、`string`型のデータを送受信できる**チャネルという部品を作成**し、それを`resultsChannel`という**変数で扱えるように割り当てる**処理です。

`make`は、スライス、マップ、チャネルという、Goの中でも特別な参照型のデータを初期化するための専用の関数です。「部品工場 (`make`)」が「ベルトコンベア (`chan string`)」を一つ作り、それに「`resultsChannel`」という名前の札を付けた、と考えると分かりやすいです。